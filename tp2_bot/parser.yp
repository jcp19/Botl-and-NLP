%{
  use utf8::all;
  my @regex_priority;
  my %regexs;
  my $count;

  # related to event management
  my @event_actions :shared;
  my @events:shared;
  my @timings :shared;
  my @durations :shared;
 
  my $prompt = ">>>";
%}

%token REGEX STRING INT COMMENT

%%
BOT : ACTIONS #{print $count,"\n";}
    ;

ACTIONS : ACTIONS ACTION #{$count++;}
       | ACTION #{$count++;}
       ;

ACTION : PATTERN_REACTION '.'
       | TIMED_EVENT '.'
       | COMMENT
       ;

TIMED_EVENT : 'SAY' STRING TIME 'AFTER' EVENT {
    push (@event_actions, $_[2]); 
    push (@timings,0);
    push (@durations, $_[3]);
    push (@events, $_[5]);
            }
            ;

TIME : INT TIME_UNIT { 
     #print $_[1], "\n";
     $_[1] * $_[2];
   }
   ;

TIME_UNIT : 'SECONDS' {1}
          | 'MINUTES' {60}
          ;

EVENT : 'LAST_MESSAGE' {"LAST_MESSAGE"}
      ;

PATTERN_REACTION : 'RESPOND' 'TO' REGEX 'WITH' STRING_LIST { 
           # print $_[3] . "=>" . $_[5];
            push(@regex_priority, $_[3]);
            $regexs{$_[3]} = $_[5];
        }
        | 'DEFAULT' 'TO' STRING_LISTS {
            unshift(@regex_priority, $_[3]);
            $regexs{""} = $_[5];
        }
      ;

STRING_LIST : STRING 'OR' STRING_LIST { 
                my $list_ref = $_[3];
                my @list = @$list_ref;
                [$_[1], @list];
            }
            | STRING { 
                my $list_ref = [$_[1]];}
            ;

%%
use threads;
use threads::shared;

my $parser=new main();
my $bot_skel =$parser->YYParse(yylex   => \&lex, yyerror => \&yyerror);

sub lex{
  CORE::state $yytext;
  if(not defined $yytext){ $yytext=join("",<>) }
  for($yytext){
    s/^\s*// ;            ## skip spaces
    $_ eq ""              and return ("", undef);
    #s/^\/(.*?)\///        and return ("REGEX", $1); 
    #s/^\"(.*?)\"//        and return ("STRING", $1);
    s/^\/(.*?)\///        and return ("REGEX", $1); 
    s/^\"(.*?)\"//        and return ("STRING", $1);
    #s/\/((?:(?!\\\/).)*)\/// and return ("REGEX", $1); 
    #s/\"((?:(?!\\\").)*)\"// and return ("STRING", $1);
    s/^#.*//              and return ("COMMENT", "");
    s/^[.]//              and return (".",".");
    s/^(\d+)//            and return ("INT", $1);
    s/^(\w+)//            and return ("$1", $1);
  }
}

sub yyerror {
  print  STDERR "Syntax Error:";
  if ($_[0]->YYCurtok) {
      printf STDERR (' a "%s" (%s) was found where %s was expected'."\n",
         $_[0]->YYCurtok, $_[0]->YYCurval, $_[0]->YYExpect)
  }
  else{ print STDERR "Expecting one of ",join(", ",$_[0]->YYExpect),"\n";}
}

#for $_ (@regex_priority) {
#    print "\"$_\"", "\n";
#}

# print @events, "\n------------------\n", @event_actions, "\n-----\n", @durations,
#  "\n-----------\n", @timings, "\n";

sub timing_events {
   while(1) {
     sleep 1;
     for my $i (@events) {
       if($timings[$i] == $durations[$i]) {
         # lacks multithreaded access control
         print "$prompt $event_actions[$i]", "\n";
         $timings[$i] = 0;
       } else {
         $timings[$i]++; 
       }
     }
   } 
}

my $thr = threads->create('timing_events');

while(<>) {
  # reset LAST_MESSAGE events
  for my $i (@events) {
    if($events[$i] == 'LAST_MESSAGE'){
        $timings[$i] = 0;
    }
  }

  chomp;
  
  for my $re (@regex_priority) {
    my $length = @{ $regexs{$re} };
    if($_ =~ /$re/i) {
      my $response = $regexs{$re}[rand $length]; 
      eval "print \"$prompt $response\n\"" and last;
    }
  }
}
$thr->join;
