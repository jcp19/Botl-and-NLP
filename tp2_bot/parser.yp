%{
  use utf8::all;
  # pattern reaction
  my @regex_priority;
  my %regexs;
  my $defaults;
  my $count;

  # related to event management
  my @event_actions :shared;
  my @events:shared;
  my @timings :shared;
  my @durations :shared;
  my @reset_strings :shared;
 
  my $prompt = ">>>";

  # environment 
  my %environment;
  my %answers;
  my $responding_to;

  # default bot variables
  my $BOT_NAME;
%}

%token REGEX STRING INT COMMENT

%%
BOT : ACTIONS {
        push (@regex_priority, "");
        $regexs{""} = $defaults;
    }
    ;

ACTIONS : ACTIONS ACTION 
       | ACTION
       ;

ACTION : PATTERN_REACTION '.'
       | TIMED_EVENT '.'
       | COMMENT
       | RESET '.'
       ;

TIMED_EVENT : 'SAY' STRING TIME 'AFTER' EVENT {
    push (@event_actions, $_[2]); 
    push (@timings,0);
    push (@durations, $_[3]);
    push (@events, $_[5]);
  }
  | 'ASK' STRING 'AND' 'RECORD' 'IN' STRING {
    push (@event_actions, $_[2]); 
    push (@timings,0);
    push (@durations, 10 + int(rand(10)));
    push (@events, "ASK");
  }
  ;

TIME : INT TIME_UNIT { 
     $_[1] * $_[2];
   }
   ;

TIME_UNIT : 'SECONDS' {1}
          | 'MINUTES' {60}
          ;

EVENT : 'LAST_MESSAGE' {"LAST_MESSAGE"}
      ;

RESET : 'RESET' 'WHEN' STRING_LIST {
           my @list = @{$_[3]};
           for my $str (@list){
             push @reset_strings, $str;
           }
      }
      ;

PATTERN_REACTION : 'RESPOND' 'TO' REGEX 'WITH' STRING_LIST { 
            push(@regex_priority, $_[3]);
            $regexs{$_[3]} = $_[5];
        }
        | 'DEFAULT' 'TO' STRING_LIST {
            $defaults = $_[3];
        }
      ;

STRING_LIST : STRING 'OR' STRING_LIST { 
                my $list_ref = $_[3];
                my @list = @$list_ref;
                [$_[1], @list];
            }
            | STRING { 
                my $list_ref = [$_[1]];
            }
            ;

%%
use threads;
use threads::shared;

my $parser=new main();
my $bot_skel =$parser->YYParse(yylex   => \&lex, yyerror => \&yyerror);

sub lex{
  CORE::state $yytext;
  if(not defined $yytext){ $yytext=join("",<>) }
  for($yytext){
    s/^\s*// ;            ## skip spaces
    $_ eq ""              and return ("", undef);
    s/^\/(.*?)\///        and return ("REGEX", $1); 
    s/^\"(.*?)\"//        and return ("STRING", $1);
    s/^#.*//              and return ("COMMENT", "");
    s/^[.]//              and return (".",".");
    s/^(\d+)//            and return ("INT", $1);
    s/^(\w+)//            and return ("$1", $1);
  }
}

sub yyerror {
  print  STDERR "Syntax Error:";
  if ($_[0]->YYCurtok) {
      printf STDERR (' a "%s" (%s) was found where %s was expected'."\n",
         $_[0]->YYCurtok, $_[0]->YYCurval, $_[0]->YYExpect)
  }
  else{ print STDERR "Expecting one of ",join(", ",$_[0]->YYExpect),"\n";}
}

sub timing_events {
   while(1) {
     sleep 1;
     for my $i (@events) {
       if($timings[$i] == $durations[$i]) {
         # lacks multithreaded access control
         print "$prompt $event_actions[$i]", "\n";
         $timings[$i] = 0;
         $durations[$i] = 8 + int(rand(10)) if $events[$i] == "ASK";
       } else {
         $timings[$i]++; 
       }
     }
   } 
}

my $thr = threads->create('timing_events');

while(<>) {
  # reset LAST_MESSAGE events
  for my $i (@events) {
    if($events[$i] == 'LAST_MESSAGE' or $events[$i] == 'ASK'){
        $timings[$i] = 0;
    }
  }

  chomp;
  my $line = $_;
  
  for my $re (@regex_priority) {
    my $length = @{ $regexs{$re} };
    if($line =~ /$re/i) {
      my $response = $regexs{$re}[rand $length]; 
      eval "print \"$prompt $response\n\"" and last;
    }
  }

  for my $str (@reset_strings) {
      if(!($str cmp $line)) {
        %environment = ();
      }
  }
}
$thr->join;
