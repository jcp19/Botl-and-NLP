%{
  my @regex_priority;
  my %regexs;
  my $count;
%}

%token REGEX STRING

%%
BOT : ACTIONS #{print $count,"\n";}
    ;

ACTIONS : ACTIONS ACTION '.' #{$count++;}
       | ACTION '.' #{$count++;}
       ;

ACTION : PATTERN_REACTION
#       | COMMENT
       ;

#COMMENT : '#' '/.*/'
#        ;

PATTERN_REACTION : 'RESPOND' 'TO' REGEX 'WITH' STRING_LIST { 
           # print $_[3] . "=>" . $_[5];
            unshift(@regex_priority, $_[3]);
            $regexs{$_[3]} = $_[5];
        }
      ;

STRING_LIST : STRING 'OR' STRING_LIST { 
                my $list_ref = $_[3];
                my @list = @$list_ref;
                [$_[1], @list];
            }
            | STRING { 
                my $list_ref = [$_[1]];}
            ;

%%

my $parser=new main();
my $bot_skel =$parser->YYParse(yylex   => \&lex, yyerror => \&yyerror);

sub lex{
  CORE::state $yytext;
  if(not defined $yytext){ $yytext=join("",<>) }
  #print(":: YYTEXT :: $yytext");
  for($yytext){
    s/^\s*// ;            ## skip spaces
    $_ eq ""              and return ("", undef);
    #s/^\/(.*?)\///        and return ("REGEX", $1); 
    #s/^\"(.*?)\"//        and return ("STRING", $1);
    s/^\/(.*?)\///        and return ("REGEX", $1); 
    s/^\"(.*?)\"//        and return ("STRING", $1);
    #s/\/((?:(?!\\\/).)*)\/// and return ("REGEX", $1); 
    #s/\"((?:(?!\\\").)*)\"// and return ("STRING", $1);
    s/^[.]//              and return (".",".");
    s/(\w+)//             and return ("$1", $1);
  }
}

sub yyerror {
  print  STDERR "Syntax Error:";
  if ($_[0]->YYCurtok) {
      printf STDERR (' a "%s" (%s) was found where %s was expected'."\n",
         $_[0]->YYCurtok, $_[0]->YYCurval, $_[0]->YYExpect)
  }
  else{ print STDERR "Expecting one of ",join(", ",$_[0]->YYExpect),"\n";}
}

while(<>) {
  chomp;
  for my $re (@regex_priority) {
    my $length = @{ $regexs{$re} };
    my $response = $regexs{$re}[rand $length]; 
    print ">> $response\n" and last if $_ =~ /$re/;
  }
}
